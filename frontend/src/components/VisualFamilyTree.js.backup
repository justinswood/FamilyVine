import React, { useEffect, useRef, useState } from 'react';
import * as d3 from 'd3';
import './VisualFamilyTree.css';

const VisualFamilyTree = () => {
  const svgRef = useRef();
  const [members, setMembers] = useState([]);
  const [relationships, setRelationships] = useState([]);
  const [selectedMember, setSelectedMember] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [treeData, setTreeData] = useState([]);

  useEffect(() => {
    fetchFamilyData();
  }, []);

  useEffect(() => {
    if (members.length > 0 && relationships.length > 0) {
      buildHierarchicalTree();
    }
  }, [members, relationships]);

  useEffect(() => {
    if (treeData.length > 0) {
      renderHierarchicalTree();
    }
  }, [treeData]);

  const fetchFamilyData = async () => {
    try {
      setLoading(true);
      const API_BASE = process.env.REACT_APP_API || 'http://192.168.1.120:5000';
      
      console.log('Fetching data from:', API_BASE);
      
      const [membersResponse, relationshipsResponse] = await Promise.all([
        fetch(`${API_BASE}/api/members`),
        fetch(`${API_BASE}/api/relationships`)
      ]);

      if (!membersResponse.ok || !relationshipsResponse.ok) {
        throw new Error(`HTTP error! Members: ${membersResponse.status}, Relationships: ${relationshipsResponse.status}`);
      }

      const membersData = await membersResponse.json();
      const relationshipsData = await relationshipsResponse.json();
      
      console.log('Fetched data:', {
        members: membersData.length,
        relationships: relationshipsData.length
      });
      
      setMembers(membersData);
      setRelationships(relationshipsData);
    } catch (error) {
      console.error('Error fetching family data:', error);
      setError(`Failed to load family data: ${error.message}`);
    } finally {
      setLoading(false);
    }
  };

  const buildHierarchicalTree = () => {
    console.log('Building hierarchical tree with members:', members.length);
    
    // Find root ancestors (Percy Manning Sr. and Alice Manning)
    const percyManning = members.find(m => 
      m.first_name?.toLowerCase().includes('percy') && 
      m.last_name?.toLowerCase().includes('manning')
    );
    
    const aliceManning = members.find(m => 
      m.first_name?.toLowerCase().includes('alice') && 
      m.last_name?.toLowerCase().includes('manning')
    );

    console.log('Found root ancestors:', { percyManning, aliceManning });

    if (!percyManning && !aliceManning) {
      // Fallback: find oldest members
      const sortedByAge = members
        .filter(m => m.birth_date || m.birth_year)
        .sort((a, b) => {
          const yearA = a.birth_year || new Date(a.birth_date).getFullYear();
          const yearB = b.birth_year || new Date(b.birth_date).getFullYear();
          return yearA - yearB;
        });
      
      if (sortedByAge.length > 0) {
        const rootGeneration = [sortedByAge[0]];
        if (sortedByAge.length > 1) rootGeneration.push(sortedByAge[1]);
        setTreeData([{ generation: 0, members: rootGeneration }]);
      }
      return;
    }

    // Build generations starting from root ancestors
    const rootGeneration = [];
    if (percyManning) rootGeneration.push(percyManning);
    if (aliceManning && aliceManning.id !== percyManning?.id) rootGeneration.push(aliceManning);

    const generations = [{ generation: 0, members: rootGeneration }];
    const processedMembers = new Set(rootGeneration.map(m => m.id));

    let currentGeneration = 0;
    let hasMoreGenerations = true;

    while (hasMoreGenerations && currentGeneration < 6) {
      const currentGenMembers = generations[currentGeneration].members;
      const nextGenMembers = [];
      const nextGenProcessed = new Set();

      currentGenMembers.forEach(parent => {
        // Find children of this parent
        const children = relationships
          .filter(rel => 
            rel.member1_id === parent.id && 
            (rel.relationship_type === 'father' || rel.relationship_type === 'mother')
          )
          .map(rel => members.find(m => m.id === rel.member2_id))
          .filter(child => child && !processedMembers.has(child.id) && !nextGenProcessed.has(child.id));

        children.forEach(child => {
          nextGenMembers.push(child);
          nextGenProcessed.add(child.id);
          processedMembers.add(child.id);

          // Add spouse if they have one
          const spouseRel = relationships.find(rel => 
            ((rel.member1_id === child.id || rel.member2_id === child.id) &&
             (rel.relationship_type === 'husband' || rel.relationship_type === 'wife' || 
              rel.relationship_type === 'spouse'))
          );

          if (spouseRel) {
            const spouseId = spouseRel.member1_id === child.id ? spouseRel.member2_id : spouseRel.member1_id;
            const spouse = members.find(m => m.id === spouseId);
            
            if (spouse && !processedMembers.has(spouse.id) && !nextGenProcessed.has(spouse.id)) {
              nextGenMembers.push(spouse);
              nextGenProcessed.add(spouse.id);
              processedMembers.add(spouse.id);
            }
          }
        });
      });

      if (nextGenMembers.length > 0) {
        generations.push({ 
          generation: currentGeneration + 1, 
          members: nextGenMembers 
        });
        currentGeneration++;
      } else {
        hasMoreGenerations = false;
      }
    }

    console.log('Built generations:', generations);
    setTreeData(generations);
  };

  const areSpouses = (member1Id, member2Id) => {
    return relationships.some(rel => 
      ((rel.member1_id === member1Id && rel.member2_id === member2Id) ||
       (rel.member1_id === member2Id && rel.member2_id === member1Id)) &&
      (rel.relationship_type === 'husband' || rel.relationship_type === 'wife' || rel.relationship_type === 'spouse')
    );
  };

  const getSpousePairs = (generation) => {
    const members = generation.members;
    const pairs = [];
    
    for (let i = 0; i < members.length; i++) {
      for (let j = i + 1; j < members.length; j++) {
        if (areSpouses(members[i].id, members[j].id)) {
          pairs.push({ member1: i, member2: j });
        }
      }
    }
    return pairs;
  };

  const getParentChildConnections = (currentGen, nextGen) => {
    const connections = [];
    
    currentGen.members.forEach((parent, parentIndex) => {
      nextGen.members.forEach((child, childIndex) => {
        const isParent = relationships.some(rel => 
          rel.member1_id === parent.id && rel.member2_id === child.id &&
          (rel.relationship_type === 'father' || rel.relationship_type === 'mother')
        );
        
        if (isParent) {
          connections.push({ 
            parentIndex, 
            childIndex,
            parentId: parent.id,
            childId: child.id
          });
        }
      });
    });
    
    return connections;
  };
  const renderHierarchicalTree = () => {
    const svg = d3.select(svgRef.current);
    svg.selectAll("*").remove();

    const margin = { top: 40, right: 40, bottom: 40, left: 40 };
    const cardWidth = 160;
    const cardHeight = 120;
    const horizontalSpacing = 200;
    const verticalSpacing = 180;

    // Calculate SVG dimensions based on tree data
    const maxMembersInGeneration = Math.max(...treeData.map(gen => gen.members.length));
    const width = Math.max(1200, maxMembersInGeneration * horizontalSpacing + margin.left + margin.right);
    const height = treeData.length * verticalSpacing + margin.top + margin.bottom;

    svg.attr('width', width).attr('height', height);

    // Create zoom behavior
    const zoom = d3.zoom()
      .scaleExtent([0.3, 2])
      .on('zoom', (event) => {
        container.attr('transform', event.transform);
      });

    svg.call(zoom);

    const container = svg.append('g')
      .attr('transform', `translate(${margin.left},${margin.top})`);

    // Create definitions for patterns (photos)
    const defs = svg.append('defs');

    // Helper function to calculate exact card position
    const getCardPosition = (genIndex, memberIndex, genMembers) => {
      const genY = genIndex * verticalSpacing;
      const startX = (width - margin.left - margin.right) / 2 - (genMembers.length - 1) * horizontalSpacing / 2;
      return {
        x: startX + memberIndex * horizontalSpacing,
        y: genY
      };
    };

    // Store all member positions for connection calculations
    const allMemberData = [];

    // STEP 1: Calculate all member positions first
    treeData.forEach((generation, genIndex) => {
      generation.members.forEach((member, memberIndex) => {
        const pos = getCardPosition(genIndex, memberIndex, generation.members);
        
        allMemberData.push({
          member: member,
          genIndex: genIndex,
          memberIndex: memberIndex,
          x: pos.x,
          y: pos.y,
          // Define precise connection points
          leftConnection: pos.x,
          rightConnection: pos.x + cardWidth,
          topConnection: pos.y,
          bottomConnection: pos.y + cardHeight,
          centerX: pos.x + cardWidth / 2,
          centerY: pos.y + cardHeight / 2
        });
      });
    });

    // STEP 2: Draw connection lines FIRST (under the cards)
    const lineContainer = container.append('g')
      .attr('class', 'connection-lines');

    console.log('Drawing connection lines for', allMemberData.length, 'members');

    // Draw spouse connection lines with improved precision
    treeData.forEach((generation, genIndex) => {
      const spousePairs = getSpousePairs(generation);
      
      spousePairs.forEach(pair => {
        const leftMember = allMemberData.find(m => 
          m.genIndex === genIndex && m.memberIndex === pair.member1
        );
        const rightMember = allMemberData.find(m => 
          m.genIndex === genIndex && m.memberIndex === pair.member2
        );

        if (leftMember && rightMember) {
          console.log('Drawing spouse line:', leftMember.member.first_name, 'to', rightMember.member.first_name);
          
          // Draw line that overlaps with card edges by 15 pixels on each side
          lineContainer.append('line')
            .attr('x1', leftMember.rightConnection + 15)  // Extend INTO the left card
            .attr('y1', leftMember.centerY)
            .attr('x2', rightMember.leftConnection - 15)  // Extend INTO the right card
            .attr('y2', rightMember.centerY)
            .attr('stroke', '#8E44AD')
            .attr('stroke-width', 4)
            .attr('class', 'spouse-line')
            .style('opacity', 0.9);

          // Add connection dots for debugging (remove later)
          lineContainer.append('circle')
            .attr('cx', leftMember.rightConnection + 15)
            .attr('cy', leftMember.centerY)
            .attr('r', 3)
            .attr('fill', '#FF0000')
            .attr('class', 'debug-dot');

          lineContainer.append('circle')
            .attr('cx', rightMember.leftConnection - 15)
            .attr('cy', rightMember.centerY)
            .attr('r', 3)
            .attr('fill', '#FF0000')
            .attr('class', 'debug-dot');
        }
      });

      // Draw parent-child connection lines with improved precision
      if (genIndex < treeData.length - 1) {
        const nextGeneration = treeData[genIndex + 1];
        const connections = getParentChildConnections(generation, nextGeneration);
        
        connections.forEach(conn => {
          const parentMember = allMemberData.find(m => 
            m.genIndex === genIndex && m.memberIndex === conn.parentIndex
          );
          const childMember = allMemberData.find(m => 
            m.genIndex === genIndex + 1 && m.memberIndex === conn.childIndex
          );

          if (parentMember && childMember) {
            console.log('Drawing parent-child line:', parentMember.member.first_name, 'to', childMember.member.first_name);
            
            // Calculate midpoint for L-shaped connection
            const midY = parentMember.bottomConnection + (childMember.topConnection - parentMember.bottomConnection) / 2;

            // Draw L-shaped path that overlaps with card edges
            lineContainer.append('path')
              .attr('d', `M ${parentMember.centerX} ${parentMember.bottomConnection + 15} 
                         L ${parentMember.centerX} ${midY} 
                         L ${childMember.centerX} ${midY} 
                         L ${childMember.centerX} ${childMember.topConnection - 15}`)
              .attr('stroke', '#4A90E2')
              .attr('stroke-width', 3)
              .attr('fill', 'none')
              .attr('class', 'parent-child-line')
              .style('opacity', 0.9);

            // Add connection dots for debugging (remove later)
            lineContainer.append('circle')
              .attr('cx', parentMember.centerX)
              .attr('cy', parentMember.bottomConnection + 15)
              .attr('r', 3)
              .attr('fill', '#00FF00')
              .attr('class', 'debug-dot');

            lineContainer.append('circle')
              .attr('cx', childMember.centerX)
              .attr('cy', childMember.topConnection - 15)
              .attr('r', 3)
              .attr('fill', '#00FF00')
              .attr('class', 'debug-dot');
          }
        });
      }
    });

    // STEP 3: Draw member cards ON TOP of the connection lines
    allMemberData.forEach((memberData) => {
      const member = memberData.member;
      
      const memberGroup = container.append('g')
        .attr('class', `member-card gen-${memberData.genIndex} member-${member.id}`)
        .attr('transform', `translate(${memberData.x}, ${memberData.y})`)
        .style('cursor', 'pointer')
        .datum(memberData)
        .on('click', function(event, d) {
          setSelectedMember(d.member);
          
          // Highlight this member
          container.selectAll('.member-card')
            .select('rect')
            .attr('stroke', '#ddd')
            .attr('stroke-width', 2);
          
          d3.select(this).select('rect')
            .attr('stroke', '#FF4444')
            .attr('stroke-width', 4);
        });

      // Add card background with opaque fill to cover lines
      memberGroup.append('rect')
        .attr('width', cardWidth)
        .attr('height', cardHeight)
        .attr('rx', 8)
        .attr('ry', 8)
        .attr('fill', 'white')
        .attr('fill-opacity', 1)  // Ensure it's fully opaque
        .attr('stroke', '#ddd')
        .attr('stroke-width', 2)
        .style('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,0.1))');

      // Add photo circles
      const API_BASE = process.env.REACT_APP_API || 'http://192.168.1.120:5000';
      
      if (member.photo_url) {
        const pattern = defs.append('pattern')
          .attr('id', `photo-${member.id}`)
          .attr('patternUnits', 'objectBoundingBox')
          .attr('width', 1)
          .attr('height', 1);

        pattern.append('image')
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', 60)
          .attr('height', 60)
          .attr('preserveAspectRatio', 'xMidYMid slice')
          .attr('href', `${API_BASE}/${member.photo_url}`);

        memberGroup.append('circle')
          .attr('cx', cardWidth / 2)
          .attr('cy', 35)
          .attr('r', 30)
          .attr('fill', `url(#photo-${member.id})`)
          .attr('stroke', member.gender === 'Male' ? '#4A90E2' : '#E24A7F')
          .attr('stroke-width', 3);
      } else {
        memberGroup.append('circle')
          .attr('cx', cardWidth / 2)
          .attr('cy', 35)
          .attr('r', 30)
          .attr('fill', member.gender === 'Male' ? '#87CEEB' : '#FFB6C1')
          .attr('stroke', member.gender === 'Male' ? '#4A90E2' : '#E24A7F')
          .attr('stroke-width', 3);

        // Add default person icon
        memberGroup.append('text')
          .attr('x', cardWidth / 2)
          .attr('y', 40)
          .attr('text-anchor', 'middle')
          .attr('font-size', '24px')
          .attr('fill', '#666')
          .text('ðŸ‘¤');
      }

      // Add names
      memberGroup.append('text')
        .attr('x', cardWidth / 2)
        .attr('y', 80)
        .attr('text-anchor', 'middle')
        .attr('font-size', '12px')
        .attr('font-weight', 'bold')
        .attr('fill', '#333')
        .text(`${member.first_name || ''} ${member.last_name || ''}`.trim() || 'Unknown');

      // Add birth/death years
      memberGroup.append('text')
        .attr('x', cardWidth / 2)
        .attr('y', 95)
        .attr('text-anchor', 'middle')
        .attr('font-size', '10px')
        .attr('fill', '#666')
        .text(() => {
          const birthYear = member.birth_year || (member.birth_date ? new Date(member.birth_date).getFullYear() : null);
          const deathYear = member.death_year || (member.death_date ? new Date(member.death_date).getFullYear() : null);
          
          if (birthYear) {
            if (deathYear) return `${birthYear} - ${deathYear}`;
            if (member.is_alive === false) return `${birthYear} - ?`;
            return `${birthYear}`;
          }
          return '';
        });

      // Add status indicator
      memberGroup.append('text')
        .attr('x', cardWidth / 2)
        .attr('y', 108)
        .attr('text-anchor', 'middle')
        .attr('font-size', '9px')
        .attr('fill', member.is_alive === false ? '#999' : '#27AE60')
        .attr('font-weight', 'bold')
        .text(member.is_alive === false ? 'DECEASED' : 'ALIVE');
    });

    // Center the initial view
    const initialScale = Math.min(
      svg.node().clientWidth / width,
      svg.node().clientHeight / height,
      1
    );
    
    svg.call(zoom.transform, d3.zoomIdentity
      .translate(svg.node().clientWidth / 2, svg.node().clientHeight / 2)
      .scale(initialScale)
      .translate(-width / 2, -height / 2));

    console.log('Rendered family tree with', allMemberData.length, 'members and connections');
  };
  if (loading) {
    return (
      <div className="flex justify-center items-center h-64">
        <div className="text-lg">Loading family tree...</div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex justify-center items-center h-64">
        <div className="text-red-600 text-center">
          <div>{error}</div>
          <div className="mt-2 text-sm">
            Check console for details. Make sure your backend is running on port 5000.
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="visual-family-tree">
      <div className="tree-controls">
        <h2>Visual Family Tree</h2>
        <div className="controls-group">
          <button 
            onClick={() => {
              const svg = d3.select(svgRef.current);
              svg.transition().duration(750)
                .call(d3.zoom().transform, d3.zoomIdentity);
            }}
            className="reset-button"
          >
            Reset View
          </button>
          <button
            onClick={() => buildHierarchicalTree()}
            className="refresh-button"
          >
            Refresh Tree
          </button>
          <button
            onClick={() => {
              // Toggle debug dots
              const svg = d3.select(svgRef.current);
              const dots = svg.selectAll('.debug-dot');
              const currentOpacity = dots.style('opacity');
              dots.style('opacity', currentOpacity === '0' ? '1' : '0');
            }}
            className="debug-button"
          >
            Toggle Debug
          </button>
        </div>
        {selectedMember && (
          <div className="selected-member-info">
            <h3>Selected: {selectedMember.first_name} {selectedMember.last_name}</h3>
            <p>Born: {selectedMember.birth_year || (selectedMember.birth_date ? new Date(selectedMember.birth_date).getFullYear() : 'Unknown')}</p>
            {selectedMember.death_year && <p>Died: {selectedMember.death_year}</p>}
            {selectedMember.location && <p>Location: {selectedMember.location}</p>}
          </div>
        )}
      </div>
      
      <div className="tree-legend">
        <h4>Family Tree Guide:</h4>
        <div className="legend-items">
          <span><div className="color-box" style={{backgroundColor: '#4A90E2'}}></div> Parent-Child connections</span>
          <span><div className="color-box" style={{backgroundColor: '#8E44AD'}}></div> Spouse connections</span>
          <span><div className="color-box" style={{backgroundColor: '#87CEEB'}}></div> Male members</span>
          <span><div className="color-box" style={{backgroundColor: '#FFB6C1'}}></div> Female members</span>
          <span><div className="color-box" style={{backgroundColor: '#27AE60'}}></div> Living members</span>
          <span><div className="color-box" style={{backgroundColor: '#999'}}></div> Deceased members</span>
          <span>ðŸ”´ Red dots: Spouse connection points</span>
          <span>ðŸŸ¢ Green dots: Parent-child connection points</span>
        </div>
      </div>
      
      <svg ref={svgRef} className="family-tree-svg"></svg>
      
      <div className="tree-stats">
        <p>Generations: {treeData.length}</p>
        <p>Total Members: {members.length}</p>
        <p>Total Relationships: {relationships.length}</p>
      </div>
    </div>
  );
};

export default VisualFamilyTree;